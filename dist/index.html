<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

	<meta property="og:image" content="/ph4.bca2043c.gif">

  <title>GPGPU Particles.</title>
</head>
<body style="margin:0; font-family: monospace;">

<canvas id="canvasgl" style="height: 100vh; width: 100vw; display: block;"></canvas>
<script src="/twgl.min.ad5822e8.js"></script>
<script>'use strict'; // particle initialization

var vInit = "\n    precision mediump float;\n    attribute vec2 position;\n    varying vec2 v_position;\n\n    void main() {\n      v_position = position;\n      gl_Position = vec4(position, 0.0, 1.0);\n    }";
var fInit = "\n    precision mediump float;\n    varying vec2 v_position;\n    uniform vec2 u_resolution;\n\n    #define rnd(x) fract(54321.987 * sin(987.12345 * x))\n\n    void main() {\n      gl_FragColor = vec4(vec3(rnd(length(v_position))), 1);\n      gl_FragColor = vec4(vec2(gl_FragCoord.xy / u_resolution), 1, 1);\n    }";
var fFeromone = "\n  precision mediump float;\nuniform sampler2D prevStateCells;\nuniform sampler2D prevStateFeromones;\nuniform float tick;\nuniform float u_time;\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nvarying vec2 uv;\n\n#define R 1. // interaction radius\n#define C 2. // max speed\n#define LOOKUP_DIST (.1*1280./u_resolution.x)\n#define LOOKUP_ANGLE (.1)\n#define rnd(x) fract(54321.987*sin(987.12345*x))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvoid main() {\n    if(tick <= 1.) {\n        gl_FragColor = vec4(0);\n        return;\n    }\n\n\n    vec4 cell = texture2D(prevStateCells, uv);\n\n    if(length(cell) > 0.) {\n        gl_FragColor += .1 * vec4(cell.ba, 0., 1.);\n        // return;\n    }\n\n    // gl_FragColor = (texture2D(prevStateFeromones, uv, .1)) * .99;\n    // gl_FragColor = texelFetch(prevStateFeromones, ivec2(gl_FragCoord.xy), 0);\n    #define diffCols 3.\n    #define diffR 3.\n    for (int i = 0; i < int(diffCols * diffCols); i++) {\n        vec2 ij = vec2(i/int(diffCols), mod(float(i), diffCols)) - (diffCols - 1.) / 2.;\n        ij *= diffR;\n        gl_FragColor += .994 * texture2D(prevStateFeromones, fract(uv+ij * 1./u_resolution)) / diffCols / diffCols;\n    }\n\n    gl_FragColor *= smoothstep(.5, .4, length(uv-.5));\n\n    float mouseSpot = max(0., .1 - length(uv - u_mouse));\n    gl_FragColor += clamp(gl_FragColor + mouseSpot * .1, 0., 1.);\n\n  }\n"; // particle physics in a cycle

var vCell = "\n    precision mediump float;\n\n    attribute vec2 position;\n    varying vec2 uv;\n\n    void main() {\n      uv = position * .5 + .5;\n      gl_Position = vec4(position, 0.0, 1.0);\n    }";
var fCell = "\n    precision mediump float;\n\n    uniform sampler2D u_texture;\n\n    precision mediump float;\nuniform sampler2D prevStateCells;\nuniform sampler2D prevStateFeromones;\nuniform float tick;\nuniform float u_time;\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nvarying vec2 uv;\n\n\n// #define prevStateFeromones prevStateCells\n#define R 1. // interaction radius\n#define C 1. // max speed\n#define LOOKUP_DIST (.2 * u_mouse.x)\n#define LOOKUP_ANGLE (3.14159265 / 4.)\n#define rnd(x) fract(54321.987*sin(987.12345*x))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define REPLICATION .03\n#define REPULSION .1\n#define DIRECTED_FEROMONES 0\n\n\nvec2 turn(vec2 uv, vec2 v){\n    vec2 sensorL = uv+(rot(-LOOKUP_ANGLE)*v)*LOOKUP_DIST; // location of sensor A\n    vec2 sensorC = uv+v*LOOKUP_DIST;\n    vec2 sensorR = uv+(rot(LOOKUP_ANGLE)*v)*LOOKUP_DIST;\n\n    float senseL, senseC, senseR;\n    if(DIRECTED_FEROMONES == 1) {\n        senseL = dot(v, texture2D(prevStateFeromones, sensorL).rg);\n        senseC = dot(v, texture2D(prevStateFeromones, sensorC).rg);\n        senseR = dot(v, texture2D(prevStateFeromones, sensorR).rg);\n    }\n    else {\n        senseL = texture2D(prevStateFeromones, sensorL).a;\n        senseC = texture2D(prevStateFeromones, sensorC).a;\n        senseR = texture2D(prevStateFeromones, sensorR).a;\n        // senseL = sensorL.x;\n        // senseC = sensorC.x;\n        // senseR = sensorR.x;\n    }\n\n    if (senseC < senseL && senseC < senseR){\n    if(rnd(v.x)<.5)\n        v*=rot(LOOKUP_ANGLE);\n    else\n        v*=rot(-LOOKUP_ANGLE);\n    }\n    else if(senseL < senseR){\n        v *= rot(-LOOKUP_ANGLE);\n    }\n    else if(senseL > senseR){\n        v *= rot(LOOKUP_ANGLE);\n    }\n    return v;\n}\n\n\nvoid main(){\n\n  // gl_FragColor = vec4(vec3(length(uv)), 1);\n    vec2 p_g, v_g;\n    vec4 n,g;\n    // if(mod(u_time, 2e5) <= .1) {\n    if(tick <= 1.) {\n        if(length(mod(vec2(gl_FragCoord.xy-.5), 10.)) == 0. && length(uv-.5) < .5)\n            // gl_FragColor = vec4(.5, .5, -(uv + .5) * .5 + .5);\n            gl_FragColor = vec4(.5, .5, .0, 1.);\n            // gl_FragColor = vec4(.5, .5, (vec2(1,0) * rot(atan(uv.y, uv.x))) * .5 + .5);\n            return;\n        }\n    float sig = rnd(length(uv)) > .5 ? 1. : -1.;\n    for(float i = -C; i <= C; i++) {\n    for(float j = -C; j <= C; j++) {\n        vec2 ij = sig * vec2(i, j);\n        vec2 uv_g = fract(uv + ij / u_resolution.xy);\n        g = texture2D(prevStateCells,uv_g);\n        if(length(g) == 0.) continue;\n        p_g = g.rg + ij;\n        v_g = g.ba;\n        if(p_g + v_g == fract(p_g + v_g)){\n        p_g = fract(p_g + v_g);\n        v_g = turn(uv_g, v_g);\n\n        //v_g+=vec2(.0,.2)*rot(atan(uv.y-.5,uv.x-.5));\n\n        vec2 g_ij = ij;\n        // for(float di=-R*sig;abs(di)<=R;di+=sig){\n            // for(float dj=-R*sig;abs(dj)<=R;dj+=sig){\n        for(float di=-R;di<=R;di+=1.){\n            for(float dj=-R;dj<=R;dj+=1.){\n                vec2 n_ij = vec2(g_ij.x + sig * di, g_ij.y + sig * dj);\n                if(length(n_ij)>0.&&length(n_ij)<R){\n                    vec2 uv_n=fract(uv+n_ij/u_resolution.xy);\n                    n=texture2D(prevStateCells,uv_n);\n                    if(length(n)==0.)continue;\n                    vec2 p_n = n.rg+n_ij;\n                    float dist=length(p_g-p_n);\n                    v_g+=REPULSION * normalize(p_g - p_n) / (dist * dist);\n                }\n            }\n        }\n\n        v_g = C * normalize(v_g);\n        gl_FragColor=vec4(p_g,v_g);\n        break;\n        }\n    }\n    }\n\n    if(length(gl_FragColor)==0.){\n        vec2 ij=vec2(.0,2.)*rot(3.14159265*.5*mod(tick,4.));\n        vec4 n=texture2D(prevStateCells,fract(uv+ij/u_resolution.xy));\n        if(length(n)==0.)\n            return;\n        if(rnd(length(uv)+u_time)<REPLICATION)\n            gl_FragColor=n;\n    }\n\n}\n\n    ";
var fDraw = "\n    precision mediump float;\n    varying vec2 uv;\n    uniform vec2 u_resolution;\n    uniform sampler2D u_texture;\n    #define rnd(x) fract(54321.987 * sin(987.12345 * x))\n    void main() {\n      gl_FragColor = vec4(texture2D(u_texture, uv).rgb, 1);\n    }";
var mousepos = [0.5, 0.5];
var tick = 0;
var canvas = document.getElementById('canvasgl');
var gl = twgl.getContext(canvas, {
  depth: false,
  antialiasing: false
});
var programInit = twgl.createProgramInfo(gl, [vInit, fInit]);
var programCell = twgl.createProgramInfo(gl, [vCell, fCell]);
var programFeromone = twgl.createProgramInfo(gl, [vCell, fFeromone]);
var programDraw = twgl.createProgramInfo(gl, [vCell, fDraw]);
var n = 512;
var m = 512;
var attachments = [{
  format: twgl.RGBA4,
  type: twgl.FLOAT32
}, {
  format: twgl.STENCIL_INDEX8
}];
var cell1 = twgl.createFramebufferInfo(gl, attachments, n, m);
var cell2 = twgl.createFramebufferInfo(gl, attachments, n, m);
var feromone1 = twgl.createFramebufferInfo(gl, attachments, n, m);
var feromone2 = twgl.createFramebufferInfo(gl, attachments, n, m);
var positionObject = {
  position: {
    data: [1, 1, 1, -1, -1, -1, -1, 1],
    numComponents: 2
  }
};
var positionBuffer = twgl.createBufferInfoFromArrays(gl, positionObject);
var pointData = [];

for (var i = 0; i < n; i++) {
  for (var j = 0; j < m; j++) {
    pointData.push(i / (n - 1));
    pointData.push(j / (m - 1));
  }
}

var pointsObject = {
  v_texcoord: {
    data: pointData,
    numComponents: 2
  }
};
var pointsBuffer = twgl.createBufferInfoFromArrays(gl, pointsObject);
var dt;
var prevTime;
var temp;
var offGravity = 0;
var restoreColors = 0;

function draw(time) {
  twgl.resizeCanvasToDisplaySize(gl.canvas);
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
  dt = prevTime ? time - prevTime : 0;
  prevTime = time; // feromones

  gl.useProgram(programFeromone.program);
  twgl.setBuffersAndAttributes(gl, programFeromone, positionBuffer);
  twgl.setUniforms(programFeromone, {
    prevStateCells: cell1.attachments[0],
    prevStateFeromones: feromone1.attachments[0],
    tick: tick,
    u_time: new Date() / 1000,
    u_resolution: [n, m],
    u_mouse: mousepos
  });
  twgl.bindFramebufferInfo(gl, feromone2);
  twgl.drawBufferInfo(gl, positionBuffer, gl.TRIANGLE_FAN); // cells

  gl.useProgram(programCell.program);
  twgl.setBuffersAndAttributes(gl, programCell, positionBuffer);
  twgl.setUniforms(programCell, {
    prevStateCells: cell1.attachments[0],
    prevStateFeromones: feromone1.attachments[0],
    tick: tick,
    u_time: new Date() / 1000,
    u_resolution: [n, m],
    u_mouse: mousepos
  });
  twgl.bindFramebufferInfo(gl, cell2);
  twgl.drawBufferInfo(gl, positionBuffer, gl.TRIANGLE_FAN);
  gl.useProgram(programDraw.program);
  twgl.setBuffersAndAttributes(gl, programDraw, positionBuffer);
  twgl.setUniforms(programDraw, {
    u_texture: cell1.attachments[0]
  });
  twgl.bindFramebufferInfo(gl, null);
  twgl.drawBufferInfo(gl, positionBuffer, gl.TRIANGLE_FAN); // ping-pong buffers

  temp = cell1;
  cell1 = cell2;
  cell2 = temp;
  temp = feromone1;
  feromone1 = feromone2;
  feromone2 = temp;
  tick++;
}

(function animate(now) {
  draw(now / 1000);
  setTimeout(requestAnimationFrame, 50, animate);
})(0);

function setMousePos(e) {
  mousepos[0] = e.clientX / gl.canvas.clientWidth;
  mousepos[1] = 1 - e.clientY / gl.canvas.clientHeight;
}

canvas.addEventListener('mousemove', setMousePos);
canvas.addEventListener('mouseleave', function () {
  mousepos[0] = 0.5;
  mousepos[1] = 0.5;
});
canvas.addEventListener('mousedown', function (e) {
  if (e.button === 0) {
    offGravity = 1;
  } else {
    restoreColors = 1;
  }
});
window.addEventListener('mouseup', function () {
  offGravity = 0;
  restoreColors = 0;
});

function handleTouch(e) {
  e.preventDefault();
  setMousePos(e.touches[0]);
}

canvas.addEventListener('contextmenu', function (e) {
  return e.preventDefault();
});
canvas.addEventListener('touchstart', handleTouch, {
  passive: false
});
canvas.addEventListener('touchmove', handleTouch, {
  passive: false
});</script>

</body>
</html>
