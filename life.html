<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

	<meta property="og:image" content="./ph4.gif">
  <style>
    body, html {
      margin: 0;
      height: 100%;
    }
  </style>
</head>
<body>

<canvas id="canvasgl" style="height: 100%; width: 100%; display: block;"></canvas>
<script src="twgl.min.js"></script>
<script>
  'use strict';

  // particle initialization
  const vInit = `
    precision mediump float;
    attribute vec2 position;
    varying vec2 v_position;
    
    void main() {
      v_position = position;
      gl_Position = vec4(position, 0.0, 1.0);
    }`;
  const fInit = `
    precision mediump float;
    varying vec2 v_position;
    uniform vec2 u_resolution;

    #define rnd(x) fract(54321.987 * sin(987.12345 * x))

    void main() {
      gl_FragColor = vec4(vec3(rnd(length(v_position))), 1);
      gl_FragColor = vec4(vec2(gl_FragCoord.xy / u_resolution), 1, 1);
    }`;


  const fFeromone = `
  precision mediump float;
uniform sampler2D prevStateCells;
uniform sampler2D prevStateFeromones;
uniform float tick;
uniform float u_time;
uniform vec2 u_resolution;
uniform vec2 u_mouse;
varying vec2 uv;

#define R 1. // interaction radius
#define C 2. // max speed
#define LOOKUP_DIST (.1*1280./u_resolution.x)
#define LOOKUP_ANGLE (.1)
#define rnd(x) fract(54321.987*sin(987.12345*x))
#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))

void main() {
    if(tick <= 1.) {
        gl_FragColor = vec4(0);
        return;
    }


    vec4 cell = texture2D(prevStateCells, uv);

    if(length(cell) > 0.) {
        gl_FragColor += .1 * vec4(cell.ba, 0., 1.);
        // return;
    }
    
    // gl_FragColor = (texture2D(prevStateFeromones, uv, .1)) * .99;
    // gl_FragColor = texelFetch(prevStateFeromones, ivec2(gl_FragCoord.xy), 0);
    #define diffCols 3.
    #define diffR 3.
    for (int i = 0; i < int(diffCols * diffCols); i++) {
        vec2 ij = vec2(i/int(diffCols), mod(float(i), diffCols)) - (diffCols - 1.) / 2.;
        ij *= diffR;
        gl_FragColor += .994 * texture2D(prevStateFeromones, fract(uv+ij * 1./u_resolution)) / diffCols / diffCols;
    }

    gl_FragColor *= smoothstep(.5, .4, length(uv-.5));

    float mouseSpot = max(0., .1 - length(uv - u_mouse));
    gl_FragColor += clamp(gl_FragColor + mouseSpot * .1, 0., 1.);

  } 
`;

  // particle physics in a cycle
  const vCell = `
    precision mediump float;

    attribute vec2 position;
    varying vec2 uv;
    
    void main() {
      uv = position * .5 + .5;
      gl_Position = vec4(position, 0.0, 1.0);
    }`;
  const fCell = `
    precision mediump float;

    uniform sampler2D u_texture;
    
    precision mediump float;
uniform sampler2D prevStateCells;
uniform sampler2D prevStateFeromones;
uniform float tick;
uniform float u_time;
uniform vec2 u_resolution;
uniform vec2 u_mouse;
varying vec2 uv;


// #define prevStateFeromones prevStateCells
#define R 1. // interaction radius
#define C 1. // max speed
#define LOOKUP_DIST (.2 * u_mouse.x)
#define LOOKUP_ANGLE (3.14159265 / 4.)
#define rnd(x) fract(54321.987*sin(987.12345*x))
#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))
#define REPLICATION .03
#define REPULSION .1
#define DIRECTED_FEROMONES 0


vec2 turn(vec2 uv, vec2 v){
    vec2 sensorL = uv+(rot(-LOOKUP_ANGLE)*v)*LOOKUP_DIST; // location of sensor A
    vec2 sensorC = uv+v*LOOKUP_DIST;
    vec2 sensorR = uv+(rot(LOOKUP_ANGLE)*v)*LOOKUP_DIST;

    float senseL, senseC, senseR;
    if(DIRECTED_FEROMONES == 1) {
        senseL = dot(v, texture2D(prevStateFeromones, sensorL).rg);
        senseC = dot(v, texture2D(prevStateFeromones, sensorC).rg);
        senseR = dot(v, texture2D(prevStateFeromones, sensorR).rg);
    }
    else {
        senseL = texture2D(prevStateFeromones, sensorL).a;
        senseC = texture2D(prevStateFeromones, sensorC).a;
        senseR = texture2D(prevStateFeromones, sensorR).a;
        // senseL = sensorL.x;
        // senseC = sensorC.x;
        // senseR = sensorR.x;
    }

    if (senseC < senseL && senseC < senseR){
    if(rnd(v.x)<.5)
        v*=rot(LOOKUP_ANGLE);
    else
        v*=rot(-LOOKUP_ANGLE);
    }
    else if(senseL < senseR){
        v *= rot(-LOOKUP_ANGLE);
    }
    else if(senseL > senseR){
        v *= rot(LOOKUP_ANGLE);
    }
    return v;
}


void main(){

  // gl_FragColor = vec4(vec3(length(uv)), 1);
    vec2 p_g, v_g;
    vec4 n,g;
    // if(mod(u_time, 2e5) <= .1) {
    if(tick <= 1.) {
        if(length(mod(vec2(gl_FragCoord.xy-.5), 10.)) == 0. && length(uv-.5) < .5)
            // gl_FragColor = vec4(.5, .5, -(uv + .5) * .5 + .5);
            gl_FragColor = vec4(.5, .5, .0, 1.);
            // gl_FragColor = vec4(.5, .5, (vec2(1,0) * rot(atan(uv.y, uv.x))) * .5 + .5);
            return;
        }
    float sig = rnd(length(uv)) > .5 ? 1. : -1.;
    for(float i = -C; i <= C; i++) {
    for(float j = -C; j <= C; j++) {
        vec2 ij = sig * vec2(i, j);
        vec2 uv_g = fract(uv + ij / u_resolution.xy);
        g = texture2D(prevStateCells,uv_g);
        if(length(g) == 0.) continue;
        p_g = g.rg + ij;
        v_g = g.ba;
        if(p_g + v_g == fract(p_g + v_g)){
        p_g = fract(p_g + v_g);
        v_g = turn(uv_g, v_g);
        
        //v_g+=vec2(.0,.2)*rot(atan(uv.y-.5,uv.x-.5));
        
        vec2 g_ij = ij;
        // for(float di=-R*sig;abs(di)<=R;di+=sig){
            // for(float dj=-R*sig;abs(dj)<=R;dj+=sig){
        for(float di=-R;di<=R;di+=1.){
            for(float dj=-R;dj<=R;dj+=1.){
                vec2 n_ij = vec2(g_ij.x + sig * di, g_ij.y + sig * dj);
                if(length(n_ij)>0.&&length(n_ij)<R){
                    vec2 uv_n=fract(uv+n_ij/u_resolution.xy);
                    n=texture2D(prevStateCells,uv_n);
                    if(length(n)==0.)continue;
                    vec2 p_n = n.rg+n_ij;
                    float dist=length(p_g-p_n);
                    v_g+=REPULSION * normalize(p_g - p_n) / (dist * dist);
                }
            }
        }
        
        v_g = C * normalize(v_g);
        gl_FragColor=vec4(p_g,v_g);
        break;
        }
    }
    }

    if(length(gl_FragColor)==0.){
        vec2 ij=vec2(.0,2.)*rot(3.14159265*.5*mod(tick,4.));
        vec4 n=texture2D(prevStateCells,fract(uv+ij/u_resolution.xy));
        if(length(n)==0.)
            return;
        if(rnd(length(uv)+u_time)<REPLICATION)
            gl_FragColor=n;
    }

}

    `;
    const fDraw = `
    precision mediump float;
    varying vec2 uv;
    uniform vec2 u_resolution;
    uniform sampler2D u_texture;
    #define rnd(x) fract(54321.987 * sin(987.12345 * x))
    void main() {
      gl_FragColor = vec4(texture2D(u_texture, uv).rgb, 1);
    }`;


  const mousepos = [0.5, 0.5];
  let tick = 0
  const canvas = document.getElementById('canvasgl');
  const gl = twgl.getContext(canvas, { depth: false, antialiasing: false });

  const programInit = twgl.createProgramInfo(gl, [vInit, fInit]);
  const programCell = twgl.createProgramInfo(gl, [vCell, fCell]);
  const programFeromone = twgl.createProgramInfo(gl, [vCell, fFeromone]);
  const programDraw = twgl.createProgramInfo(gl, [vCell, fDraw]);

  const n = 512;
  const m = 512;
  const attachments = [
    { format: twgl.RGBA4, type: twgl.FLOAT32},
    { format: twgl.STENCIL_INDEX8 },
  ]
  let cell1 = twgl.createFramebufferInfo(gl, attachments, n, m);
  let cell2 = twgl.createFramebufferInfo(gl, attachments, n, m);
  let feromone1 = twgl.createFramebufferInfo(gl, attachments, n, m);
  let feromone2 = twgl.createFramebufferInfo(gl, attachments, n, m);
  const positionObject = { position: { data: [1, 1, 1, -1, -1, -1, -1, 1], numComponents: 2 } };
  const positionBuffer = twgl.createBufferInfoFromArrays(gl, positionObject);

  const pointData = [];
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      pointData.push(i / (n - 1));
      pointData.push(j / (m - 1));
    }
  }
  const pointsObject = { v_texcoord: { data: pointData, numComponents: 2 } };
  const pointsBuffer = twgl.createBufferInfoFromArrays(gl, pointsObject);

  let dt;
  let prevTime;
  let temp;
  let offGravity = 0;
  let restoreColors = 0;

  function draw(time) {
    twgl.resizeCanvasToDisplaySize(gl.canvas);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    dt = (prevTime) ? time - prevTime : 0;
    prevTime = time;

    // feromones
    gl.useProgram(programFeromone.program);
    twgl.setBuffersAndAttributes(gl, programFeromone, positionBuffer);
    twgl.setUniforms(programFeromone, {
      prevStateCells: cell1.attachments[0],
      prevStateFeromones: feromone1.attachments[0],
      tick: tick,
      u_time: new Date() / 1000,
      u_resolution: [n, m],
      u_mouse: mousepos,
    });
    twgl.bindFramebufferInfo(gl, feromone2);
    twgl.drawBufferInfo(gl, positionBuffer, gl.TRIANGLE_FAN);


    // cells
    gl.useProgram(programCell.program);
    twgl.setBuffersAndAttributes(gl, programCell, positionBuffer);
    twgl.setUniforms(programCell, {
      prevStateCells: cell1.attachments[0],
      prevStateFeromones: feromone1.attachments[0],
      tick: tick,
      u_time: new Date() / 1000,
      u_resolution: [n, m],
      u_mouse: mousepos,
    });
    twgl.bindFramebufferInfo(gl, cell2);
    twgl.drawBufferInfo(gl, positionBuffer, gl.TRIANGLE_FAN);

    gl.useProgram(programDraw.program);
    twgl.setBuffersAndAttributes(gl, programDraw, positionBuffer);
    twgl.setUniforms(programDraw, {
      u_texture: cell1.attachments[0],
    });
    twgl.bindFramebufferInfo(gl, null);
    twgl.drawBufferInfo(gl, positionBuffer, gl.TRIANGLE_FAN);



    // ping-pong buffers
    temp = cell1;
    cell1 = cell2;
    cell2 = temp;

    temp = feromone1;
    feromone1 = feromone2;
    feromone2 = temp;

    tick++
  }

  (function animate(now) {
    draw(now / 1000);
    setTimeout(requestAnimationFrame, 50, animate);
  })(0);

  function setMousePos(e) {
    mousepos[0] = e.clientX / gl.canvas.clientWidth;
    mousepos[1] = 1 - e.clientY / gl.canvas.clientHeight;
  }

  canvas.addEventListener('mousemove', setMousePos);

  canvas.addEventListener('mouseleave', () => {
    mousepos[0] = 0.5;
    mousepos[1] = 0.5;
  });
  
  canvas.addEventListener('mousedown', e => {
    if (e.button === 0) {
      offGravity = 1;
    } else {
      restoreColors = 1;
    }
  });

  window.addEventListener('mouseup', () => {
    offGravity = 0;
    restoreColors = 0;
  });

  function handleTouch(e) {
    e.preventDefault();
    setMousePos(e.touches[0]);
  }

  canvas.addEventListener('contextmenu', e => e.preventDefault());
  canvas.addEventListener('touchstart', handleTouch, {passive: false});
  canvas.addEventListener('touchmove', handleTouch, {passive: false});

</script>

</body>
</html>
