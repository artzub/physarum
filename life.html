<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

	<meta property="og:image" content="physarum.png">

  <title>GPGPU Particles.</title>
</head>
<body style="margin:0; font-family: monospace;">

<canvas id="canvasgl" style="height: 100vh; width: 100vw; display: block;"></canvas>
<div id="b" style="position: absolute; top: 10px; width: 100%; text-align: center; z-index: 2;"><a href="http://twgljs.org">twgl.js</a> - GPGPU Particles.</div>

<script src="twgl.min.js"></script>
<script>
  'use strict';

  // particle initialization
  const vInit = `
    precision mediump float;
    attribute vec2 position;
    varying vec2 v_position;
    
    void main() {
      v_position = position;
      gl_Position = vec4(position, 0.0, 1.0);
    }`;
  const fInit = `
    precision mediump float;
    varying vec2 v_position;
    uniform vec2 u_resolution;

    #define rnd(x) fract(54321.987 * sin(987.12345 * x))

    void main() {
      gl_FragColor = vec4(vec3(rnd(length(v_position))), 1);
      gl_FragColor = vec4(vec2(gl_FragCoord.xy / u_resolution), 1, 1);
    }`;

  // particle physics in a cycle
  const vPhysics = `
    precision mediump float;

    attribute vec2 position;
    varying vec2 uv;
    
    void main() {
      uv = position * .5 + .5;
      gl_Position = vec4(position, 0.0, 1.0);
    }`;
  const fPhysics = `
    precision mediump float;

    varying vec2 uv;
    uniform sampler2D u_texture;
    
    void main() {
      vec4 prevCol = texture2D(u_texture, uv);
      gl_FragColor = vec4(vec3(1.-prevCol.rgb),1);
      // gl_FragColor = vec4(uv, 1., 1.);
    }
    `;

  // drawing particles
  const vDraw = `
    precision mediump float;

    attribute vec2 v_texcoord;
    uniform sampler2D u_texture;
    varying vec3 color;   

    vec3 hsv2rgb(vec3 c) {
      vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
      return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
    }

    void main () {
      vec4 particle = texture2D(u_texture, v_texcoord);
      color = hsv2rgb(vec3(0.5 * v_texcoord + 0.4, 0.9));
      gl_Position = vec4(particle.xy * 2.0 - 1.0, 0.0, 1.0);
      gl_PointSize = 1.0;
    }`;
  const fDraw = `
    precision mediump float;
    varying vec3 color;

    void main () {
      gl_FragColor = vec4(color, 1.);
    }`;

  const mousepos = [0.5, 0.5];
  const canvas = document.getElementById('canvasgl');
  const gl = twgl.getContext(canvas, { depth: false, antialiasing: false });

  const programInit = twgl.createProgramInfo(gl, [vInit, fInit]);
  const programPhysics = twgl.createProgramInfo(gl, [vPhysics, fPhysics]);
  const programDraw = twgl.createProgramInfo(gl, [vDraw, fDraw]);

  const n = 8;
  const m = 8;
  let fb1 = twgl.createFramebufferInfo(gl, undefined, n, m);
  let fb2 = twgl.createFramebufferInfo(gl, undefined, n, m);
  const positionObject = { position: { data: [1, 1, 1, -1, -1, -1, -1, 1], numComponents: 2 } };
  const positionBuffer = twgl.createBufferInfoFromArrays(gl, positionObject);

  const pointData = [];
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      pointData.push(i / (n - 1));
      pointData.push(j / (m - 1));
    }
  }
  const pointsObject = { v_texcoord: { data: pointData, numComponents: 2 } };
  const pointsBuffer = twgl.createBufferInfoFromArrays(gl, pointsObject);

  // particle initialization
  gl.useProgram(programInit.program);
  twgl.setBuffersAndAttributes(gl, programInit, positionBuffer);
  twgl.setUniforms(programInit, {
      u_resolution: [n, m],
  });
  twgl.bindFramebufferInfo(gl, fb1);
  twgl.drawBufferInfo(gl, positionBuffer, gl.TRIANGLE_FAN);

  gl.useProgram(programInit.program);
  twgl.setBuffersAndAttributes(gl, programInit, positionBuffer);
  twgl.bindFramebufferInfo(gl, fb2);
  twgl.drawBufferInfo(gl, positionBuffer, gl.TRIANGLE_FAN);

  let dt;
  let prevTime;
  let temp;
  let offGravity = 0;
  let restoreColors = 0;

  function draw(time) {
    twgl.resizeCanvasToDisplaySize(gl.canvas);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    dt = (prevTime) ? time - prevTime : 0;
    prevTime = time;

    // particle physics
    gl.useProgram(programPhysics.program);
    twgl.setBuffersAndAttributes(gl, programPhysics, positionBuffer);
    twgl.setUniforms(programPhysics, {
      u_texture: fb1.attachments[0],
    });
    twgl.bindFramebufferInfo(gl, fb2);
    twgl.drawBufferInfo(gl, positionBuffer, gl.TRIANGLE_FAN);

    gl.useProgram(programPhysics.program);
    twgl.setBuffersAndAttributes(gl, programPhysics, positionBuffer);
    twgl.setUniforms(programPhysics, {
      u_texture: fb2.attachments[0],
    });
    twgl.bindFramebufferInfo(gl, null);
    twgl.drawBufferInfo(gl, positionBuffer, gl.TRIANGLE_FAN);

    // // drawing particles
    // gl.useProgram(programDraw.program);
    // twgl.setBuffersAndAttributes(gl, programPhysics, positionBuffer);
    // twgl.setUniforms(programDraw, {
    //   u_texture: fb2.attachments[0],
    //   gravity_center: mousepos,
    //   off_gravity: offGravity,
    //   restore_colors: restoreColors,
    //   dt: 2.5 * dt,
    // });
    // twgl.bindFramebufferInfo(gl, null);
    // twgl.drawBufferInfo(gl, positionBuffer, gl.TRIANGLE_FAN);

    // ping-pong buffers
    temp = fb1;
    fb1 = fb2;
    fb2 = temp;
  }

  (function animate(now) {
    draw(now / 1000);
    setTimeout(requestAnimationFrame, 500, animate);
  })(0);

  function setMousePos(e) {
    mousepos[0] = e.clientX / gl.canvas.clientWidth;
    mousepos[1] = 1 - e.clientY / gl.canvas.clientHeight;
  }

  canvas.addEventListener('mousemove', setMousePos);

  canvas.addEventListener('mouseleave', () => {
    mousepos[0] = 0.5;
    mousepos[1] = 0.5;
  });
  
  canvas.addEventListener('mousedown', e => {
    if (e.button === 0) {
      offGravity = 1;
    } else {
      restoreColors = 1;
    }
  });

  window.addEventListener('mouseup', () => {
    offGravity = 0;
    restoreColors = 0;
  });

  function handleTouch(e) {
    e.preventDefault();
    setMousePos(e.touches[0]);
  }

  canvas.addEventListener('contextmenu', e => e.preventDefault());
  canvas.addEventListener('touchstart', handleTouch, {passive: false});
  canvas.addEventListener('touchmove', handleTouch, {passive: false});

</script>

</body>
</html>
